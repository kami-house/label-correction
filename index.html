
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Corrige NF</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        .container {
            display: flex;
            gap: 20px;
        }
        textarea {
            width: 300px;
            height: 400px;
            padding: 10px;
            font-size: 16px;
        }
        button {
            display: block;
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div class="container">
    <div>
        <h3>Texto ERRADO da Bling</h3>
        <textarea id="inputText"></textarea>
        <button onclick="processText()">CORRIGIR</button>
    </div>
    <div>
        <h3>Texto corrigido</h3>
        <textarea id="outputText" readonly></textarea>
    </div>
</div>

<script>
    const fetchWithRetry = async (url, options, retries = 5, backoff = 300) => {
        for (let i = 0; i <= retries; i++) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response;
            } catch (error) {
                if (i < retries) {
                    // Wait for the backoff time before retrying
                    await new Promise(resolve => setTimeout(resolve, backoff));
                    backoff *= 2; // Increase backoff time exponentially
                } else {
                    // After all retries fail, throw the error
                    throw error;
                }
            }
        }
    };
    function processText() {
        const inputText = document.getElementById('inputText').value;
        const notification = document.getElementById('notification');
        const outputTextArea = document.getElementById('outputText');
        outputTextArea.value = 'Carregando...';

        // Split the input text by lines
        const lines = inputText.split('\n');
        let currentTTT = '';
        const tttBlocks = [];
        let capturing = false;

        lines.forEach(line => {
            const newTTT = line.includes('^XA~TA000~JSN') && line.includes('^GFA') ? line.split('^XA~TA000~JSN')[0] : line
            currentTTT += newTTT + '\n';
            if (line.includes('^XA~TA000~JSN') && line.includes('^GFA')) {
                // console.log('inside if', '^XA~TA000~JSN' + line.split('^XA~TA000~JSN')[1])
                // console.log('currentTTT', currentTTT)
                if (currentTTT && currentTTT !== '\n') {
                    tttBlocks.push(currentTTT);
                }
                currentTTT = '^XA~TA000~JSN' + line.split('^XA~TA000~JSN')[1]  + '\n';
            }
        });
        tttBlocks.push(currentTTT)
        console.log(tttBlocks)

// Altera√ß√£o proposta chatgpt
        
// Agrupar blocos por nota
const groupedNotes = [];
let note = [];

tttBlocks.forEach(block => {
    if (block.includes('^XA~TA000~JSN')) {
        if (note.length > 0) {
            groupedNotes.push(note);
        }
        note = [block];
    } else {
        note.push(block);
    }
});

// Adiciona a √∫ltima nota
if (note.length > 0) {
    groupedNotes.push(note);
}

// Apenas as duas primeiras p√°ginas de cada nota
const filteredBlocks = groupedNotes.flatMap(notePages => notePages.slice(0, 2));

// üß™ LOG de verifica√ß√£o
console.log("Blocos filtrados para envio √† API:", filteredBlocks);

// Requisi√ß√£o para API de corre√ß√£o
const promises = filteredBlocks.map(ttt => {
    return fetchWithRetry('https://mxmvvlqa32.execute-api.sa-east-1.amazonaws.com/prod/backend/fixlabel', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ ttt })
    })
    .then(response => response.json())
    .then(data => {
        const processed = JSON.parse(data.body).processed_text;
        if (!processed.includes('^XA') || !processed.includes('^XZ')) {
            throw new Error("ZPL inv√°lido retornado da API.");
        }
        return processed;
    })
    .catch(error => {
        console.error("Erro na API de corre√ß√£o:", error);
        return '^XA\nErro ao processar etiqueta\n^XZ';
    });
});

// Enviar para Labelary
Promise.all(promises).then(processedTexts => {
    const zpl = processedTexts.join('\n\n');
    document.getElementById('outputText').value = zpl;

    const blob = new Blob([zpl], { type: 'text/plain' });
    const formData = new FormData();
    formData.append('file', blob);

    // Envio para Labelary para gerar PDF
    fetch('https://api.labelary.com/v1/printers/8dpmm/labels/4x6/', {
        method: 'POST',
        headers: {
            'Accept': 'application/pdf'
        },
        body: formData
    })
    .then(response => {
        if (!response.ok) throw new Error('Erro ao gerar PDF com Labelary.');
        return response.blob();
    })
    .then(blob => {
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'label.pdf';
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
    })
    .catch(error => {
        console.error('Erro ao gerar ou baixar o PDF:', error);
        alert("Erro ao gerar o PDF. Veja o console para detalhes.");
    });
});

// Altera√ß√£o proposta chatgpt
        
</script>

</body>
</html>
